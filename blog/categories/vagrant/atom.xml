<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Vagrant | Sean's Blog]]></title>
  <link href="http://www.seanguo.com/blog/categories/vagrant/atom.xml" rel="self"/>
  <link href="http://www.seanguo.com/"/>
  <updated>2017-04-01T17:50:50+08:00</updated>
  <id>http://www.seanguo.com/</id>
  <author>
    <name><![CDATA[Sean Guo]]></name>
    <email><![CDATA[seanguo85@qq.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Vagrant+Chef]]></title>
    <link href="http://www.seanguo.com/blog/2017/03/12/vagrant-plus-chef/"/>
    <updated>2017-03-12T19:32:51+08:00</updated>
    <id>http://www.seanguo.com/blog/2017/03/12/vagrant-plus-chef</id>
    <content type="html"><![CDATA[<h2>引言</h2>

<p>前面我介绍了Chef的环境搭建和简单的cookbook的创建执行，也介绍了如果用Vagrant来快速搭建一台虚拟机。但是所有的东西都停留在hello world的阶段，这篇文章就是结合这两个生产力工具来搭建一组<del>可以实际使用</del>用来做rails开发的server。</p>

<h2>Chef Provisioning</h2>

<p>我们知道Vagrant包含多种不同类型的provisioner，而Chef就是其中内置的一种，所以我们是可以直接使用的。这里我们用到的是chef_solo, Chef Solo是Chef Client的单机版，运行不依赖于Chef Server。</p>

<p>第一步我们要下载我们需要安装的组件的cookbook，这里我们会用到第三方的cookbook，因为在<a href="https://supermarket.chef.io/cookbooks/">社区</a>里已经有很多成熟的cookbook了。但是手工下载的方式不太方便，这里我们用到cookbook的依赖管理的工具: <a href="https://docs.chef.io/berkshelf.html">Berkshelf</a>。它和Ruby的gem管理文件Gemfile语法类似，它的配置文件是Berksfile。我们在当前文件夹（我这里是<strong>vagrant_test</strong>）创建一个空的Berksfile。chef-dk里面已经包含Berkshelf的命令行工具了，对应的命令是<strong>berks</strong>, 但是Vagrant想要用Berkshelf的时候我们还要装个插件来实现，可以用下面的命令来安装最新Berkshelf的插件。
{% codeblock lang:bash%}
vagrant plugin install vagrant-berkshelf
{% endcodeblock %}</p>

<p>然后编辑Berksfile加上如下两行：
{% codeblock lang:ruby%}
source &lsquo;<a href="https://supermarket.chef.io">https://supermarket.chef.io</a>&rsquo;</p>

<p>cookbook &lsquo;rails&rsquo;, &lsquo;~> 0.9.2&rsquo;
{% endcodeblock %}
source语句指定了去supermarket.chef.io搜索下载cookbook, 第二行声明我们依赖于一个叫rails的cookbook，version为0.9.2，关于version的语法可以<a href="https://docs.chef.io/config_rb_metadata.html#cookbook-version-constraints">戳这里</a>。</p>

<p>我们接着创建一个新的Vagrantfile, 这里我们打算创建两个虚拟机，一个作为rails的主server，另一个用来安装mysql。我们先看第一台虚拟机的配置：
{% codeblock lang:ruby%}</p>

<h1>&ndash;<em>&ndash; mode: ruby &ndash;</em>&ndash;</h1>

<h1>vi: set ft=ruby :</h1>

<p>Vagrant.configure(&ldquo;2&rdquo;) do |config|</p>

<p>  #base box for all machines
  config.vm.box = &ldquo;bento/centos-6.7&rdquo;</p>

<p>  #define a VM named rails
  config.vm.define &ldquo;rails&rdquo; do |rails|</p>

<pre><code>rails.vm.provider "virtualbox" do |v, override|
  v.name           = "rails"
  override.vm.network :private_network, ip: "192.168.50.20"
end

#configure chef provisoning per VM
rails.vm.provision "shell", inline: "yum -y groupinstall 'Development Tools'"

rails.vm.provision "chef_solo" do |chef|
  chef.node_name = "rails"
  chef.log_level = :debug
  chef.json = {
    "run_list" =&gt; ["rails"]
  }
end
</code></pre>

<p>  end
end
{% endcodeblock %}
然后我们启动这台rails虚拟机，多虚拟机配置的启动需要指定虚拟机的名字，要不就是默认全部启动。
{% codeblock lang:bash%}
vagrant up rails
{% endcodeblock %}
这块儿由于是第一次启动这个虚拟机，它会首先下载需要的cookbook，然后映射到虚拟机里，启动虚拟机之后会首先下载安装Chef，这个过程很耗时间。</p>

<p>这里定义了两个provisioning，一个是用sh安装Rails依赖的开发工具包。另一个是利用rails这个cookbook来配置Rails的环境。
我这块遇到了在墙内会超时的问题。科学上网后解决了但是还是很耗时间，主要是下载Chef的安装包费时间。我们可以在其装好了chef和dev tools之后把这个box存起来作为以后的base box。命令如下:
{% codeblock lang:bash%}
vagrant package &mdash;base rails
vagrant box add mybase package.box
{% endcodeblock %}
安装完box之后可以用下面的命令查看是否安装成功:
{% codeblock lang:bash%}
vagrant box list                <br/>
bento/centos-6.7 (virtualbox, 2.2.7)
mybase           (virtualbox, 0)
{% endcodeblock %}
以后就可以用mybase作为box的name来复用已经下载安装好Chef和dev tools的box。</p>

<p>安装成功后我们可以用如下命令登录进去:
{% codeblock lang:bash%}
vagrant ssh rails
{% endcodeblock %}</p>

<p>然后我们定义另外一个虚拟机用来安装mysql，这里我们取名为mysql:
{% codeblock lang:ruby%}
config.vm.define &ldquo;mysql&rdquo; do |mysql|</p>

<pre><code>mysql.vm.provider "virtualbox" do |v, override|
  v.name           = "mysql"
  override.vm.network :private_network, ip: "192.168.50.21"
end

mysql.vm.provision "chef_solo" do |chef|
  chef.node_name = "mysql"
  chef.log_level = :debug
  chef.json = {
    "run_list" =&gt; ["vagrant_chef::mysql"]
  }
end
</code></pre>

<p> end
{% endcodeblock %}
因为对这个cookbook的调用不能直接通过runlist，需要在recipe里调用它的resource来进行，我们需要把当前目录变成一个cookbook。一个cookbook的最小因素就是一个用来自描述的metadata.rb
{% codeblock lang:ruby%}
name             &ldquo;vagrant_chef&rdquo;
maintainer       &ldquo;YOUR_NAME&rdquo;
maintainer_email &ldquo;YOUR_EMAIL&rdquo;
license          &ldquo;All rights reserved&rdquo;
description      &ldquo;Installs/Configures mysql server&rdquo;
version          &ldquo;0.0.1&rdquo;</p>

<p>depends &ldquo;mysql&rdquo;
{% endcodeblock %}
这里我们还要加上对mysql的依赖，只有这样才能保证使用mysql的resource之前对mysql的依赖都全部被加载好。然后我们需要在Berksfile里指定mysql的cookbook版本，这样Berkshelf插件才会把这个新依赖的cookbook抓下来:
{% codeblock lang:ruby%}
source &lsquo;<a href="https://supermarket.chef.io">https://supermarket.chef.io</a>&rsquo;
metadata</p>

<p>cookbook &lsquo;rails&rsquo;, &lsquo;~> 0.9.2&rsquo;</p>

<p>cookbook &lsquo;mysql&rsquo;, &lsquo;~> 8.2.0&rsquo;
{% endcodeblock %}
我们还加上了一行metadata，表示我们解析当前目录的metadata.rb, 把当前这个cookbook也加载进来。然后我们创建一个receipes文件夹，创建一个mysql.rb:
{% codeblock lang:ruby%}
mysql_service &lsquo;mysql&rsquo; do
  port &lsquo;3306&rsquo;
  version &lsquo;5.5&rsquo;
  initial_root_password &lsquo;change me&rsquo;
  action [:create, :start]
end
{% endcodeblock %}
这个Recipe用来安装设置mysql， 可以看到上面我们中对虚拟机的provisioning的配置里可以通过把<strong>vagrant_chef::mysql</strong>加到runlist来实现对这个Recipe的调用。
所有都做好我们可以调用
{% codeblock lang:bash%}
vagrant up mysql
{% endcodeblock %}
这样mysql这个虚拟机也会被创建设置好。</p>

<p>本来就想写个vagrant+chef的教程，结果大部分时间花在调试这两个别人写的cookbook。终于还是放弃了，所以这个教程的Chef安装部分是跑不起来的，仅供参考。但是其中你也能学到多个虚拟机的配置，组网，如何在Vagrant使用Chef, Berkshelf这些东西。</p>

<p>完整的Vagrantfile如下：</p>

<p>{% codeblock lang:ruby%}</p>

<h1>&ndash;<em>&ndash; mode: ruby &ndash;</em>&ndash;</h1>

<h1>vi: set ft=ruby :</h1>

<p>Vagrant.configure(&ldquo;2&rdquo;) do |config|</p>

<p>  #base box for all machines
  config.vm.box = &ldquo;bento/centos-6.7&rdquo;</p>

<p>  #define a VM named rails
  config.vm.define &ldquo;rails&rdquo; do |rails|</p>

<pre><code>rails.vm.provider "virtualbox" do |v, override|
  v.name           = "rails"
  override.vm.network :private_network, ip: "192.168.50.20"
end

#configure chef provisoning per VM
rails.vm.provision "shell", inline: "yum -y groupinstall 'Development Tools'"

rails.vm.provision "chef_solo" do |chef|
  chef.node_name = "rails"
  chef.log_level = :debug
  chef.json = {
    "run_list" =&gt; ["rails"]
  }
end
</code></pre>

<p>  end</p>

<p>  config.vm.define &ldquo;mysql&rdquo; do |mysql|</p>

<pre><code>mysql.vm.provider "virtualbox" do |v, override|
  v.name           = "mysql"
  override.vm.network :private_network, ip: "192.168.50.21"
end

mysql.vm.provision "chef_solo" do |chef|
  chef.node_name = "mysql"
  chef.log_level = :debug
  chef.json = {
    "run_list" =&gt; ["vagrant_chef::mysql"]
  }
end
</code></pre>

<p>  end
end</p>

<p>{% endcodeblock %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Vagrant 入门]]></title>
    <link href="http://www.seanguo.com/blog/2016/11/16/vagrant-ru-men/"/>
    <updated>2016-11-16T11:48:43+08:00</updated>
    <id>http://www.seanguo.com/blog/2016/11/16/vagrant-ru-men</id>
    <content type="html"><![CDATA[<h2>介绍</h2>

<p>Vagrant是一个虚拟机管理工具，通过它你可以用几个简单的命令快速搭建一个配置好的虚拟机环境。它提供了多种虚拟机provider所以你可以用同一个设置文件去驱动设置不同的虚拟机。<br><br>
它的核心文件叫做Vagrantfile，所有的虚拟机的配置都是在这里。我们可以在里面定义各个provider的配置，如果去用provisioner去设置虚拟机，安装应用程序。有了这个配置文件，你就可以很方便的快速重复构建一个测试环境。这让Docker出现之前成为了开发员很热衷的一个环境设置工具。
我这篇文章将会一步一步来搭建一个测试环境。这样从头来讲解Vagrant的基本使用方法，希望可以帮到那些想要学习Vagrant的人。</p>

<h2>初始设置</h2>

<p>首先你需要去<a href="https://www.vagrantup.com/downloads.html">下载</a>适合你操作系统的Vagrant安装包。安装完之后我们还需要安装<a href="https://www.virtualbox.org/">VirtualBox</a>来作为演示用的provider。因为Virtualbox是Vagrant的provider，当然当你熟悉Vagrant之后可以通过修改全局的配置文件来修改默认的provider。一切都安装好了之后我们需要打开一个shell窗口，新建一个文件夹作为这次演示用的。
{% codeblock lang:bash%}
mkdir vagrant_leanring
cd vagrant_leanring
vagrant init
{% endcodeblock %}
这里用到了第一个命令 <em>vagrant init</em> 这个命令会在当然目录生成如下这样的一个Vagrantfile，我们可以以这个为模板来修改运行我们自己的演示。
{% codeblock lang:ruby%}</p>

<h1>&ndash;<em>&ndash; mode: ruby &ndash;</em>&ndash;</h1>

<h1>vi: set ft=ruby :</h1>

<h1>All Vagrant configuration is done below. The &ldquo;2&rdquo; in Vagrant.configure</h1>

<h1>configures the configuration version (we support older styles for</h1>

<h1>backwards compatibility). Please don&rsquo;t change it unless you know what</h1>

<h1>you&rsquo;re doing.</h1>

<p>Vagrant.configure(2) do |config|
  # The most common configuration options are documented and commented below.
  # For a complete reference, please see the online documentation at
  # <a href="https://docs.vagrantup.com.">https://docs.vagrantup.com.</a></p>

<p>  # Every Vagrant development environment requires a box. You can search for
  # boxes at <a href="https://atlas.hashicorp.com/search.">https://atlas.hashicorp.com/search.</a>
  config.vm.box = &ldquo;base&rdquo;</p>

<p>  # Disable automatic box update checking. If you disable this, then
  # boxes will only be checked for updates when the user runs
  # <code>vagrant box outdated</code>. This is not recommended.
  # config.vm.box_check_update = false</p>

<p>  # Create a forwarded port mapping which allows access to a specific port
  # within the machine from a port on the host machine. In the example below,
  # accessing &ldquo;localhost:8080&rdquo; will access port 80 on the guest machine.
  # config.vm.network &ldquo;forwarded_port&rdquo;, guest: 80, host: 8080</p>

<p>  # Create a private network, which allows host-only access to the machine
  # using a specific IP.
  # config.vm.network &ldquo;private_network&rdquo;, ip: &ldquo;192.168.33.10&rdquo;</p>

<p>  # Create a public network, which generally matched to bridged network.
  # Bridged networks make the machine appear as another physical device on
  # your network.
  # config.vm.network &ldquo;public_network&rdquo;</p>

<p>  # Share an additional folder to the guest VM. The first argument is
  # the path on the host to the actual folder. The second argument is
  # the path on the guest to mount the folder. And the optional third
  # argument is a set of non-required options.
  # config.vm.synced_folder &ldquo;../data&rdquo;, &ldquo;/vagrant_data&rdquo;</p>

<p>  # Provider-specific configuration so you can fine-tune various
  # backing providers for Vagrant. These expose provider-specific options.
  # Example for VirtualBox:
  #
  # config.vm.provider &ldquo;virtualbox&rdquo; do |vb|
  #   # Display the VirtualBox GUI when booting the machine
  #   vb.gui = true
  #
  #   # Customize the amount of memory on the VM:
  #   vb.memory = &ldquo;1024&rdquo;
  # end
  #
  # View the documentation for the provider you are using for more
  # information on available options.</p>

<p>  # Define a Vagrant Push strategy for pushing to Atlas. Other push strategies
  # such as FTP and Heroku are also available. See the documentation at
  # <a href="https://docs.vagrantup.com/v2/push/atlas.html">https://docs.vagrantup.com/v2/push/atlas.html</a> for more information.
  # config.push.define &ldquo;atlas&rdquo; do |push|
  #   push.app = &ldquo;YOUR_ATLAS_USERNAME/YOUR_APPLICATION_NAME&rdquo;
  # end</p>

<p>  # Enable provisioning with a shell script. Additional provisioners such as
  # Puppet, Chef, Ansible, Salt, and Docker are also available. Please see the
  # documentation for more information about their specific syntax and use.
  # config.vm.provision &ldquo;shell&rdquo;, inline: &lt;&lt;-SHELL
  #   sudo apt-get update
  #   sudo apt-get install -y apache2
  # SHELL
end</p>

<p>{% endcodeblock %}
我们可以看到里面有一些很好的注释来帮助我们快速的生成自己需要的配置。这里能看到这个文件的格式是Ruby语法的，因为Vagrant这个工具是用Ruby来实现，所以为了更好的了解这个配置文件我们会在下一章讲解一下基本的Ruby语法。因为Ruby也是学习Chef需要的语言，我会在下一篇blog里讲解一下基础的Chef知识。</p>

<h2>Vagrant需要了解的Ruby语法</h2>

<p>我们通过上面的Vagrantfile看到Ruby里面的注释是用<em>#</em>来开始的。然后我们看到了
{% codeblock lang:ruby%}
Vagrant.configure(2) do |config|
end
{% endcodeblock %}
这个其实是调用了Vagrant这个mudule上的configure方法，这个方法接受两个参数：第一个参数是2（表示Version），第二个参数是一个代码块(block)，因为根据Ruby的语法, 方法最后一个参数为block的时候我们可以放到括号外面，这种调用也等价于
{% codeblock lang:ruby%}
Vagrant.configure(2) { |config|
}
{% endcodeblock %}
这是block的两种表示方法，通过这种block的形式我们可以很方便的把一段代码作为参数传给一个方法。这里这个方法的作用就是去设置Vagrant的各项参数。我们可以看到被注释的代码里面也很多再次用到了嵌套的block的方式。<br><br>
需要更多的了解Ruby这门语言的话，这里有个很好的学习Ruby的<a href="http://ruby-doc.com/docs/ProgrammingRuby/">网站</a>，虽然是英文的但是值得一读。</p>

<h2>Box</h2>

<p>现在block的配置里唯一打开注释的就是
{% codeblock lang:ruby%}
config.vm.box = &ldquo;base&rdquo;
{% endcodeblock %}
Box是你的虚拟机启动时用的base image,所以你就不必从头去设置一个虚拟机。你可以去社区下载已经基本配置好的Box，然后基于它去搭建虚拟机。你可以去<a href="https://atlas.hashicorp.com/boxes/search">HashiCorp&rsquo;s Atlas box catalog</a>去查看社区已有的Box。这个<em>base</em>就是其中一个Box，<em>base</em>是这个Box的id。我们可以用下面的命令去添加一个Box到我们的本地环境中：
{% codeblock lang:bash%}
vagrant box add hashicorp/precise32
{% endcodeblock %}
如果你用的OS是Mac的话，默认下载好的Box会被安装在<em>~/.vagrant.d/boxes</em>。然后我们修改Vagrantfile使用我们导入好的Box，因为base目前是不存在的：
{% codeblock lang:ruby%}
config.vm.box = &ldquo;hashicorp/precise32&rdquo;
{% endcodeblock %}</p>

<h2>Commands</h2>

<ul>
<li><em>vagrant up</em> 是启动一个虚拟机，默认的话会在Virtualbox里导入你指定的Box，然后启动。</li>
</ul>


<p>如果这时候你没有用<em>vagrant box add</em>导入Box的话，这时候Vagrant也会自动下载导入对于的Box。这个命令成功执行完毕之后你会在VirtualBox看到多了一个虚拟机。这个虚拟机的名字是<em>vagrant_learning_default_xxxxxx_xxx</em>。虚拟机名字的前面可以看出来是文件夹的名字，后面的default表示是默认的虚拟机因为一个Vagrantfile可以配置多个虚拟机，这个后面我们会看到。<br>
启动好了之后我们可以用<em>vagrant ssh</em>直接进到机器里。
与up相对应的命令有<br></p>

<ul>
<li><em>vagrant destroy</em> 销毁删除一个创建好的虚拟机。一般我们彻底不用的时候才会这样做，更常用的</li>
<li><em>vagrant halt</em> 关闭一个虚拟机，就是把虚拟机关机，这样的话就不会占用Cpu和内存。</li>
</ul>


<p>还有不太常用的命令像 <em>vagrant suspend/resume</em>是挂起或者恢复虚拟机。更多的可以参考官方文档。</p>

<h2>Provider</h2>

<p>Provider是Vagrant用来和不同种类虚拟机通信的驱动，我们在一个Vagrantfile可以配置多种Provider。安装好Vagrant好默认的Provider就是VirtualBox，所以我们在执行命令时不用传入Provider的名字。实际情况下我们有可能在一个Vagrantfile配置多个Provider来应对开发测试的不同阶段，例如我们可以配置一个VirtualBox的Provider做本地开发/测试，然后再定义一个EC2的Provider来部署到Amazon的云里，这样的配置就像下面这样:
{% codeblock lang:ruby%}</p>

<p>config.vm.provider &ldquo;virtualbox&rdquo; do |vb|</p>

<pre><code># Display the VirtualBox GUI when booting the machine
</code></pre>

<p>  vb.gui = true</p>

<p>  # Customize the amount of memory on the VM:
  vb.memory = &ldquo;1024&rdquo;</p>

<p>  # Configure the virtual machine name displayed in VirtualBox
  vb.name = &ldquo;vagrant_leanring&rdquo;
end</p>

<p>config.vm.provider :aws do |aws,overide|</p>

<pre><code>aws.security_groups           =  %w(everything_open)
aws.access_key_id             =  "YOUR KEY"
aws.secret_access_key         =  "YOUR SECRET KEY"
aws.ami                       =  "ami-xxx"
aws.instance_type             =  "m1.medium"
aws.keypair_name              =  "KEYPAIR NAME"

overide.ssh.username              =  "root"
overide.ssh.private_key_path      =  "PATH TO YOUR PRIVATE KEY" 
overide.vm.box                    =  'dummy'
</code></pre>

<p>end</p>

<p>{% endcodeblock %}</p>

<p>这样配置以后你可以用<em>vagrant up &mdash;provider=aws</em>来远程启动AWS云里的虚拟机。当然之前你需要安装AWS的<a href="https://github.com/mitchellh/vagrant-aws">Provider</a>和配置这个Provider需要的dummy Box。
{% codeblock lang:bash%}
vagrant plugin install vagrant-aws</p>

<p>vagrant box add dummy <a href="https://github.com/mitchellh/vagrant-aws/raw/master/dummy.box">https://github.com/mitchellh/vagrant-aws/raw/master/dummy.box</a>
{% endcodeblock %}
接下来的教程我们还是以VirtualBox这个Provider为例来讲解。</p>

<h2>Shared folders</h2>

<p>我们接下来可以打开注释里的<em>config.vm.synced_folder</em>并修改映射到已经存在的一个文件夹。以我的机器为例：
{% codeblock lang:ruby%}
config.vm.synced_folder &ldquo;../training&rdquo;, &ldquo;/vagrant_data&rdquo;
{% endcodeblock %}
这样的话可以把本机Host里的一个文件夹映射到Guest虚拟机里。修改这个设置之后需要重启虚拟机来生效，命令是
{% codeblock lang:ruby%}
vagrant reload
{% endcodeblock %}
这样启动完之后登陆后你可以看到映射的文件夹:
{% codeblock lang:bash%}
vagrant ssh</p>

<p>vagrant@precise32:~$ ll /vagrant_data/
total 16
drwxr-xr-x  1 vagrant vagrant  238 Jul  4 10:40 ./
drwxr-xr-x 24 root    root    4096 Nov 18 02:25 ../
drwxr-xr-x  1 vagrant vagrant  170 Jul  4 10:39 cookbooks/
drwxr-xr-x  1 vagrant vagrant  272 Jan  8  2016 Docker/
-rw-r&mdash;r&mdash;  1 vagrant vagrant 8196 Jul  4 10:40 .DS_Store
drwxr-xr-x  1 vagrant vagrant  102 Jul  4 10:39 intro/
drwxr-xr-x  1 vagrant vagrant  102 Apr  5  2016 .vagrant/
{% endcodeblock %}</p>

<h2>Network</h2>

<p>默认的虚拟机的网络是NAT形式的，我们可以从Vagrant启动的log里看出来：
{% codeblock lang:bash%}
==> default: Preparing network interfaces based on configuration&hellip;</p>

<pre><code>default: Adapter 1: nat
</code></pre>

<p>==> default: Forwarding ports&hellip;</p>

<pre><code>default: 22 =&gt; 2202 (adapter 1)
</code></pre>

<p>{% endcodeblock %}
我们可以看到默认做了一个端口映射，所以我们可以通过访问本机端口2202来访问虚拟机的22(ssh)端口:
{% codeblock lang:bash%}
ssh <a href="&#109;&#97;&#105;&#108;&#116;&#x6f;&#x3a;&#x76;&#x61;&#x67;&#114;&#97;&#x6e;&#116;&#64;&#x31;&#x32;&#x37;&#46;&#x30;&#46;&#48;&#x2e;&#x31;">&#x76;&#x61;&#103;&#114;&#97;&#x6e;&#x74;&#64;&#x31;&#x32;&#55;&#x2e;&#48;&#46;&#x30;&#46;&#x31;</a> -p 2202
The authenticity of host &lsquo;[127.0.0.1]:2202 ([127.0.0.1]:2202)&rsquo; can&rsquo;t be established.
ECDSA key fingerprint is SHA256:q7StLmS/+YYwF42lL4HQJdMQGcAPpkKgzVlxORTisGE.
Are you sure you want to continue connecting (yes/no)? yes</p>

<p><a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#111;&#58;&#x76;&#x61;&#x67;&#x72;&#x61;&#x6e;&#x74;&#64;&#49;&#x32;&#55;&#46;&#x30;&#x2e;&#48;&#46;&#x31;">&#118;&#97;&#x67;&#114;&#x61;&#x6e;&#116;&#64;&#49;&#x32;&#x37;&#46;&#x30;&#x2e;&#48;&#46;&#x31;</a>&rsquo;s password:</p>

<p>Last login: Fri Nov 18 02:26:09 2016 from 10.0.2.2
vagrant@precise32:~$
{% endcodeblock %}
这个就是vagrant ssh的实现原理，默认的用户名是<em>vagrant</em>密码也是<em>vagrant</em>。这样的网络结构做一些简单的部署测试可以的，比方说我们可以定义本机的8080端口映射到虚拟机的80端口：
{% codeblock lang:ruby%}
config.vm.network &ldquo;forwarded_port&rdquo;, guest: 80, host: 8080
{% endcodeblock %}
修改网络拓扑结构和配置之后也有重启虚拟机。从启动log我们可以看到端口成功映射了
{% codeblock lang:bash%}
==> default: Forwarding ports&hellip;</p>

<pre><code>default: 80 =&gt; 8080 (adapter 1)
default: 22 =&gt; 2202 (adapter 1)
</code></pre>

<p>==> default: Running &lsquo;pre-boot&rsquo; VM customizations&hellip;
{% endcodeblock %}
还有一种常用的网络结构是<em>private_network</em>，这种网络结构会创建一个只有主机能和虚拟机通信的私网，这种是通过指定虚拟机内网IP的形式来配置:
{% codeblock lang:ruby%}
config.vm.network &ldquo;private_network&rdquo;, ip: &ldquo;192.168.33.10&rdquo;
{% endcodeblock %}
这样的配置启动后，Host本机会拥有IP <em>192.168.33.1</em>, 这样本机和虚拟机就是一个网段，通信就没有障碍了。最后一种形式是<em>public_network</em>,这种就是为虚拟机建一个Bridge的网络，相当于虚拟机变成你现有网络里另一台机器。但是这种是受限于网络要求的，像我们公司就是不允许这种网络结构的，你的虚拟机得不到IP。<br>
当然这里网络配置都是针对本地的虚拟机，像是AWS，Openstack这种云里的虚拟机所在自己的Provider配置里来配置的。一般网络结构受限于云和Provider插件支持的类型。</p>

<h2>Provisioner</h2>

<p>现在虚拟机已经启动好了，我们需要配置,部署一些软件上去，这就用到了Provisioner。Vagrantfile也支持多个Provisioner，它们会按配置顺序挨个执行。例如我们可以打开注释里的：
{% codeblock lang:ruby%}
 config.vm.provision &ldquo;shell&rdquo;, inline: &lt;&lt;-SHELL
   sudo apt-get update
   sudo apt-get install -y apache2
 SHELL
{% endcodeblock %}
修改完之后我们又要用到一个新命令:
{% codeblock lang:bash%}
vagrant provision
{% endcodeblock %}
这个命令会执行所有定义的provision命令block。之后我们会在控制台看到很长的一段输出，成功执行之后我们就装好了Apache, 我们可以打开浏览器试一试。因为我们已经配置好了端口映射，所以访问本机的8080端口应该能到Apache的欢迎页面。</p>

<blockquote><p>It works!</p>

<p>This is the default web page for this server.</p>

<p>The web server software is running but no content has been added, yet.</p></blockquote>

<br>


<p>这篇教程用到的完整Vagrantfile（去掉了一些注释）如下:
{% codeblock lang:ruby%}
v# &ndash;<em>&ndash; mode: ruby &ndash;</em>&ndash;</p>

<h1>vi: set ft=ruby :</h1>

<p>Vagrant.configure(2) do |config|</p>

<p>  # Every Vagrant development environment requires a box. You can search for
  # boxes at <a href="https://atlas.hashicorp.com/search.">https://atlas.hashicorp.com/search.</a>
  config.vm.box = &ldquo;hashicorp/precise32&rdquo;</p>

<p>  # Create a forwarded port mapping which allows access to a specific port
  # within the machine from a port on the host machine. In the example below,
  # accessing &ldquo;localhost:8080&rdquo; will access port 80 on the guest machine.
  config.vm.network &ldquo;forwarded_port&rdquo;, guest: 80, host: 8080</p>

<p>  # Share an additional folder to the guest VM. The first argument is
  # the path on the host to the actual folder. The second argument is
  # the path on the guest to mount the folder. And the optional third
  # argument is a set of non-required options.
  config.vm.synced_folder &ldquo;../training&rdquo;, &ldquo;/vagrant_data&rdquo;</p>

<p>  # Provider-specific configuration so you can fine-tune various
  # backing providers for Vagrant. These expose provider-specific options.
  # Example for VirtualBox:
  config.vm.provider &ldquo;virtualbox&rdquo; do |vb|</p>

<pre><code># Display the VirtualBox GUI when booting the machine
vb.gui = true

# Customize the amount of memory on the VM:
vb.memory = "1024"

# Configure the virtual machine name displayed in VirtualBox
vb.name = "vagrant_leanring"
</code></pre>

<p>  end</p>

<p>  config.vm.provider :aws do |aws,overide|</p>

<pre><code>  aws.security_groups           =  %w(everything_open)
  aws.access_key_id             =  "YOUR KEY"
  aws.secret_access_key         =  "YOUR SECRET KEY"
  aws.ami                       =  "ami-xxx"
  aws.instance_type             =  "m1.medium"
  aws.keypair_name              =  "KEYPAIR NAME"

  overide.ssh.username              =  "root"
  overide.ssh.private_key_path      =  "PATH TO YOUR PRIVATE KEY" 
  overide.vm.box                    =  'dummy'
</code></pre>

<p>  end</p>

<p>  # Enable provisioning with a shell script. Additional provisioners such as
  # Puppet, Chef, Ansible, Salt, and Docker are also available. Please see the
  # documentation for more information about their specific syntax and use.
  config.vm.provision &ldquo;shell&rdquo;, inline: &lt;&lt;-SHELL</p>

<pre><code>sudo apt-get update
sudo apt-get install -y apache2
</code></pre>

<p>  SHELL
end</p>

<p>{% endcodeblock %}</p>

<br><br>


<p>这篇教程到这就告一段落了，我想我还会写第二部分讲述如何用一个Vagrantfile配置多个虚拟机，然后讲完Chef后还会写一个结合Vagrant和Chef的教程。</p>
]]></content>
  </entry>
  
</feed>
